# Production Makefile для EduPlatform
# Использование: make -f Makefile.prod [command]

.PHONY: help install start stop restart status logs backup restore update cleanup ssl monitoring

# Переменные
DOCKER_COMPOSE := docker compose -f docker-compose.prod.yml
MONITORING_COMPOSE := docker compose -f docker-compose.monitoring.yml
PROJECT_DIR := /opt/eduplatform
DATE := $(shell date +"%Y%m%d_%H%M%S")

# Цвета
GREEN := \033[0;32m
YELLOW := \033[1;33m
RED := \033[0;31m
NC := \033[0m

help: ## Показать справку
	@echo "$(GREEN)EduPlatform - Production Commands$(NC)"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "  $(YELLOW)%-15s$(NC) %s\n", $$1, $$2}'
	@echo ""

# === ОСНОВНЫЕ КОМАНДЫ ===

install: ## Полная установка (первый раз)
	@echo "$(GREEN)Установка системы...$(NC)"
	@sudo apt update && sudo apt upgrade -y
	@sudo apt install -y curl wget git vim htop nginx certbot python3-certbot-nginx ufw
	@curl -fsSL https://get.docker.com | sudo sh
	@sudo systemctl enable docker
	@sudo systemctl start docker
	@echo "$(GREEN)Установка завершена$(NC)"

start: ## Запустить все сервисы
	@echo "$(GREEN)Запуск приложения...$(NC)"
	@$(DOCKER_COMPOSE) up -d
	@echo "$(GREEN)Ожидание запуска БД...$(NC)"
	@sleep 10
	@$(DOCKER_COMPOSE) exec -T backend alembic upgrade head || $(DOCKER_COMPOSE) run --rm backend alembic upgrade head
	@echo "$(GREEN)Приложение запущено$(NC)"
	@make status

stop: ## Остановить все сервисы
	@echo "$(YELLOW)Остановка приложения...$(NC)"
	@$(DOCKER_COMPOSE) down
	@echo "$(GREEN)Приложение остановлено$(NC)"

restart: ## Перезапустить все сервисы
	@echo "$(YELLOW)Перезапуск приложения...$(NC)"
	@make stop
	@sleep 3
	@make start

# === МОНИТОРИНГ ===

status: ## Показать статус всех сервисов
	@echo "$(GREEN)=== Статус сервисов ===$(NC)"
	@$(DOCKER_COMPOSE) ps
	@echo ""
	@echo "$(GREEN)=== Health Check ===$(NC)"
	@docker inspect --format='Backend: {{.State.Health.Status}}' eduplatform-backend 2>/dev/null || echo "Backend: не запущен"
	@docker inspect --format='Frontend: {{.State.Health.Status}}' eduplatform-frontend 2>/dev/null || echo "Frontend: не запущен"
	@docker inspect --format='PostgreSQL: {{.State.Health.Status}}' eduplatform-postgres 2>/dev/null || echo "PostgreSQL: не запущен"
	@docker inspect --format='Redis: {{.State.Health.Status}}' eduplatform-redis 2>/dev/null || echo "Redis: не запущен"

logs: ## Показать логи всех сервисов
	@$(DOCKER_COMPOSE) logs -f

logs-backend: ## Показать логи backend
	@$(DOCKER_COMPOSE) logs -f backend

logs-frontend: ## Показать логи frontend
	@$(DOCKER_COMPOSE) logs -f frontend

logs-celery: ## Показать логи celery worker
	@$(DOCKER_COMPOSE) logs -f celery-worker

logs-nginx: ## Показать логи nginx
	@$(DOCKER_COMPOSE) logs -f nginx

stats: ## Показать использование ресурсов
	@docker stats --no-stream

# === BACKUP & RESTORE ===

backup: ## Создать полный бэкап
	@echo "$(GREEN)Создание бэкапа...$(NC)"
	@mkdir -p backups/postgres backups/redis
	@docker exec eduplatform-postgres pg_dump -U eduplatform eduplatform_prod | gzip > backups/postgres/backup_$(DATE).sql.gz
	@docker exec eduplatform-redis redis-cli SAVE
	@docker cp eduplatform-redis:/data/dump.rdb backups/redis/dump_$(DATE).rdb
	@tar -czf backups/storage_$(DATE).tar.gz backend/storage 2>/dev/null || true
	@echo "$(GREEN)Бэкап создан:$(NC)"
	@echo "  PostgreSQL: backups/postgres/backup_$(DATE).sql.gz"
	@echo "  Redis: backups/redis/dump_$(DATE).rdb"
	@echo "  Storage: backups/storage_$(DATE).tar.gz"

restore: ## Восстановить из бэкапа (указать DATE=YYYYMMDD_HHMMSS)
ifndef DATE
	@echo "$(RED)Ошибка: укажите дату бэкапа: make restore DATE=20231201_120000$(NC)"
	@exit 1
endif
	@echo "$(YELLOW)Восстановление из бэкапа $(DATE)...$(NC)"
	@$(DOCKER_COMPOSE) stop backend celery-worker
	@gunzip < backups/postgres/backup_$(DATE).sql.gz | docker exec -i eduplatform-postgres psql -U eduplatform eduplatform_prod
	@$(DOCKER_COMPOSE) stop redis
	@docker cp backups/redis/dump_$(DATE).rdb eduplatform-redis:/data/dump.rdb
	@$(DOCKER_COMPOSE) start redis
	@tar -xzf backups/storage_$(DATE).tar.gz 2>/dev/null || true
	@$(DOCKER_COMPOSE) start backend celery-worker
	@echo "$(GREEN)Восстановление завершено$(NC)"

backup-auto-setup: ## Настроить автоматические бэкапы (cron)
	@echo "$(GREEN)Настройка автоматических бэкапов...$(NC)"
	@(crontab -l 2>/dev/null; echo "0 2 * * * cd $(PROJECT_DIR) && make -f Makefile.prod backup >> logs/backup.log 2>&1") | crontab -
	@echo "$(GREEN)Автобэкап настроен: каждый день в 2:00$(NC)"

# === ОБНОВЛЕНИЕ ===

update: backup ## Обновить приложение (с автобэкапом)
	@echo "$(GREEN)Обновление приложения...$(NC)"
	@git pull origin main
	@$(DOCKER_COMPOSE) down
	@$(DOCKER_COMPOSE) build --no-cache
	@$(DOCKER_COMPOSE) up -d
	@sleep 10
	@$(DOCKER_COMPOSE) exec -T backend alembic upgrade head || $(DOCKER_COMPOSE) run --rm backend alembic upgrade head
	@docker image prune -f
	@echo "$(GREEN)Обновление завершено$(NC)"
	@make status

rollback: ## Откатить к предыдущему коммиту
	@echo "$(YELLOW)Откат к предыдущей версии...$(NC)"
	@git reset --hard HEAD~1
	@make update

# === SSL СЕРТИФИКАТЫ ===

ssl-generate: ## Получить SSL сертификаты через Let's Encrypt
	@echo "$(GREEN)Получение SSL сертификатов...$(NC)"
	@$(DOCKER_COMPOSE) stop nginx
	@sudo certbot certonly --standalone \
		-d yourdomain.com \
		-d www.yourdomain.com \
		-d api.yourdomain.com \
		--email your-email@example.com \
		--agree-tos \
		--no-eff-email
	@sudo cp /etc/letsencrypt/live/yourdomain.com/fullchain.pem nginx/ssl/
	@sudo cp /etc/letsencrypt/live/yourdomain.com/privkey.pem nginx/ssl/
	@sudo chmod 644 nginx/ssl/fullchain.pem
	@sudo chmod 600 nginx/ssl/privkey.pem
	@$(DOCKER_COMPOSE) start nginx
	@echo "$(GREEN)SSL сертификаты установлены$(NC)"

ssl-renew: ## Обновить SSL сертификаты
	@echo "$(GREEN)Обновление SSL сертификатов...$(NC)"
	@sudo certbot renew --quiet
	@sudo cp /etc/letsencrypt/live/yourdomain.com/*.pem nginx/ssl/
	@$(DOCKER_COMPOSE) restart nginx
	@echo "$(GREEN)SSL сертификаты обновлены$(NC)"

ssl-auto-renew-setup: ## Настроить автообновление SSL (cron)
	@echo "$(GREEN)Настройка автообновления SSL...$(NC)"
	@(crontab -l 2>/dev/null; echo "0 3 * * * cd $(PROJECT_DIR) && make -f Makefile.prod ssl-renew >> logs/ssl.log 2>&1") | crontab -
	@echo "$(GREEN)Автообновление SSL настроено: каждый день в 3:00$(NC)"

# === БАЗА ДАННЫХ ===

db-shell: ## Подключиться к PostgreSQL shell
	@$(DOCKER_COMPOSE) exec postgres psql -U eduplatform eduplatform_prod

db-migrate: ## Запустить миграции
	@echo "$(GREEN)Запуск миграций...$(NC)"
	@$(DOCKER_COMPOSE) exec -T backend alembic upgrade head

db-migrate-create: ## Создать новую миграцию (указать MSG="описание")
ifndef MSG
	@echo "$(RED)Ошибка: укажите описание миграции: make db-migrate-create MSG=\"add user table\"$(NC)"
	@exit 1
endif
	@$(DOCKER_COMPOSE) exec backend alembic revision --autogenerate -m "$(MSG)"

db-rollback: ## Откатить последнюю миграцию
	@echo "$(YELLOW)Откат миграции...$(NC)"
	@$(DOCKER_COMPOSE) exec backend alembic downgrade -1

# === REDIS ===

redis-shell: ## Подключиться к Redis CLI
	@$(DOCKER_COMPOSE) exec redis redis-cli

redis-flush: ## Очистить Redis (осторожно!)
	@echo "$(RED)Внимание! Это удалит все данные из Redis$(NC)"
	@read -p "Продолжить? [y/N] " -n 1 -r; \
	if [[ $$REPLY =~ ^[Yy]$$ ]]; then \
		$(DOCKER_COMPOSE) exec redis redis-cli FLUSHALL; \
		echo "$(GREEN)Redis очищен$(NC)"; \
	fi

# === CELERY ===

celery-purge: ## Очистить очередь Celery
	@echo "$(YELLOW)Очистка очереди Celery...$(NC)"
	@$(DOCKER_COMPOSE) exec celery-worker celery -A app.infrastructure.queue.celery_app purge -f

celery-inspect: ## Показать активные задачи Celery
	@$(DOCKER_COMPOSE) exec celery-worker celery -A app.infrastructure.queue.celery_app inspect active

celery-stats: ## Показать статистику Celery
	@$(DOCKER_COMPOSE) exec celery-worker celery -A app.infrastructure.queue.celery_app inspect stats

# === МОНИТОРИНГ (ДОПОЛНИТЕЛЬНЫЕ ИНСТРУМЕНТЫ) ===

monitoring-start: ## Запустить инструменты мониторинга
	@echo "$(GREEN)Запуск инструментов мониторинга...$(NC)"
	@$(MONITORING_COMPOSE) up -d
	@echo "$(GREEN)Мониторинг запущен:$(NC)"
	@echo "  Portainer: http://localhost:9000"
	@echo "  Grafana: http://localhost:3001"
	@echo "  Prometheus: http://localhost:9090"
	@echo "  pgAdmin: http://localhost:5050"
	@echo "  Redis Commander: http://localhost:8081"

monitoring-stop: ## Остановить инструменты мониторинга
	@$(MONITORING_COMPOSE) down

# === ОЧИСТКА ===

cleanup: ## Очистить неиспользуемые Docker ресурсы
	@echo "$(YELLOW)Очистка системы...$(NC)"
	@docker image prune -af
	@docker container prune -f
	@docker volume prune -f
	@docker network prune -f
	@find backups/postgres -name "backup_*.sql.gz" -mtime +30 -delete 2>/dev/null || true
	@find backups/redis -name "dump_*.rdb" -mtime +30 -delete 2>/dev/null || true
	@echo "$(GREEN)Очистка завершена$(NC)"

cleanup-logs: ## Очистить старые логи
	@echo "$(YELLOW)Очистка логов...$(NC)"
	@find logs -name "*.log" -mtime +7 -delete 2>/dev/null || true
	@truncate -s 0 logs/nginx/access.log logs/nginx/error.log 2>/dev/null || true
	@echo "$(GREEN)Логи очищены$(NC)"

# === РАЗРАБОТКА / ОТЛАДКА ===

shell-backend: ## Зайти в контейнер backend
	@$(DOCKER_COMPOSE) exec backend /bin/bash

shell-frontend: ## Зайти в контейнер frontend
	@$(DOCKER_COMPOSE) exec frontend /bin/sh

test-backend: ## Запустить тесты backend
	@$(DOCKER_COMPOSE) exec backend pytest

test-api: ## Протестировать API endpoints
	@echo "$(GREEN)Тестирование API...$(NC)"
	@curl -f http://localhost:8000/health || echo "$(RED)Backend недоступен$(NC)"
	@curl -f http://localhost:3000 || echo "$(RED)Frontend недоступен$(NC)"

# === СИСТЕМНЫЕ КОМАНДЫ ===

systemd-install: ## Установить systemd service
	@echo "$(GREEN)Установка systemd service...$(NC)"
	@sudo cp scripts/eduplatform.service /etc/systemd/system/
	@sudo systemctl daemon-reload
	@sudo systemctl enable eduplatform.service
	@echo "$(GREEN)Systemd service установлен$(NC)"
	@echo "Используйте: sudo systemctl start eduplatform"

systemd-start: ## Запустить через systemd
	@sudo systemctl start eduplatform

systemd-stop: ## Остановить через systemd
	@sudo systemctl stop eduplatform

systemd-status: ## Показать статус systemd service
	@sudo systemctl status eduplatform

# === ПОЛНАЯ УСТАНОВКА ===

full-install: install ## Полная установка на чистом сервере
	@echo "$(GREEN)Полная установка...$(NC)"
	@make firewall-setup
	@make user-create
	@make dirs-create
	@echo "$(GREEN)Установка завершена. Настройте .env файлы и запустите: make start$(NC)"

firewall-setup: ## Настроить файрвол UFW
	@echo "$(GREEN)Настройка файрвола...$(NC)"
	@sudo ufw --force enable
	@sudo ufw allow ssh
	@sudo ufw allow http
	@sudo ufw allow https
	@sudo ufw status
	@echo "$(GREEN)Файрвол настроен$(NC)"

user-create: ## Создать пользователя eduplatform
	@id eduplatform &>/dev/null || (sudo useradd -m -s /bin/bash eduplatform && sudo usermod -aG docker eduplatform)
	@echo "$(GREEN)Пользователь eduplatform создан$(NC)"

dirs-create: ## Создать необходимые директории
	@mkdir -p nginx/{conf.d,ssl} logs/{backend,frontend,celery,nginx} backups/{postgres,redis}
	@echo "$(GREEN)Директории созданы$(NC)"
